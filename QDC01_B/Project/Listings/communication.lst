C51 COMPILER V9.60.7.0   COMMUNICATION                                                     06/27/2025 11:35:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN ..\Output\communication.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\BSP\Src\communication.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\
                    -BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\communication.lst) OBJEC
                    -T(..\Output\communication.obj)

line level    source

   1          #include "communication.h"
   2          
   3          RS485 rs485;
   4          SATA  sata;
   5          
   6          // uint8_t TX1_busy_Flag = 0;
   7          
   8          /**
   9           * @brief       串口4调用结构体 rs485 初始化
  10           *
  11           * @param   
  12           *
  13           * @return  void
  14          **/
  15          void Uart4_Send_Statu_Init( void )
  16          {
  17   1          rs485.RX4_rev_end_Flag = 0;
  18   1          rs485.TX4_buf[128] = 0;
  19   1          rs485.RX4_buf[128] = 0;
  20   1          rs485.TX4_send_bytelength = 0;
  21   1          rs485.TX4_send_cnt = 0;
  22   1          rs485.RX4_rev_timeout = 0;
  23   1          rs485.RX4_rev_cnt = 0;
  24   1          DR_485 = 0;
  25   1          rs485.scan_04_flag = 1;
  26   1          rs485.connect_flag = 0;
  27   1          rs485.conntct_statu  = 0;
  28   1      }
  29          
  30          /**
  31           * @brief       串口4调用结构体 rs485 初始化
  32           *
  33           * @param   
  34           *
  35           * @return  void
  36          **/
  37          void Uart1_Send_Statu_Init( void )
  38          {
  39   1          sata.RX1_rev_end_Flag = 0;
  40   1          sata.TX1_buf[128] = 0;
  41   1          sata.RX1_buf[128] = 0;
  42   1          sata.TX1_send_bytelength = 0;
  43   1          sata.TX1_send_cnt = 0;
  44   1          sata.RX1_rev_timeout = 0;
  45   1          sata.RX1_rev_cnt = 0;
  46   1      }
  47          
  48          /**
  49           * @brief       串口4中断处理函数
  50           *
  51           * @param   
  52           *
  53           * @return  void
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     06/27/2025 11:35:29 PAGE 2   

  54          **/
  55          void Uart4_ISR() interrupt 18 
  56          {   
  57   1      
  58   1          /* 1, 检测到S4TI置1，即发送完毕                       */
  59   1          if( S4CON & S4TI )          //
  60   1          {
  61   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
  62   2              S4CON &= ~S4TI;         
  63   2              
  64   2              /* 3, 依次将TX4_buf中数据送出（写S4BUF操作即为发送）    */
  65   2              if( rs485.TX4_send_bytelength != 0 )
  66   2              {
  67   3                  S4BUF = rs485.TX4_buf[rs485.TX4_send_cnt++];
  68   3                  rs485.TX4_send_bytelength--;
  69   3              }else
  70   2              {
  71   3                  rs485.TX4_send_cnt = 0;
  72   3                  DR_485 = 0;
  73   3              }
  74   2          }
  75   1          
  76   1          /* 1, 检测到S2RI置1，即接收完毕                       */
  77   1          if( S4CON & S4RI )
  78   1          {
  79   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  80   2              S4CON &= ~S4RI;
  81   2              /* 3, 判断数据包是否接收完毕                           */
  82   2              if( !rs485.RX4_rev_end_Flag )
  83   2              {
  84   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
  85   3                  if( rs485.RX4_rev_cnt > 128 )
  86   3                  {
  87   4                      rs485.RX4_rev_cnt = 0;
  88   4                  }
  89   3      
  90   3                  /* 5, 依次将RX4_buf中数据接收（读S2BUF操作即为接收）*/
  91   3                  rs485.RX4_buf[rs485.RX4_rev_cnt] = S4BUF;
  92   3                  rs485.RX4_rev_cnt++;
  93   3              }
  94   2              /* 6, 重置接收完毕判断时间                              */
  95   2              rs485.RX4_rev_timeout = 5;
  96   2          }
  97   1      }
  98          
  99          
 100          /**
 101           * @brief       串口1中断处理函数
 102           *
 103           * @param   
 104           *
 105           * @return  void
 106          **/
 107          void Uart1_ISR() interrupt 4 
 108          {   
 109   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 110   1          if( TI == 1 )          //
 111   1          {
 112   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 113   2              TI = 0;         
 114   2              
 115   2              /* 3, 依次将TX4_buf中数据送出（写S4BUF操作即为发送）    */
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     06/27/2025 11:35:29 PAGE 3   

 116   2              if( sata.TX1_send_bytelength != 0 )
 117   2              {
 118   3                  SBUF = sata.TX1_buf[sata.TX1_send_cnt++];
 119   3                  sata.TX1_send_bytelength--;
 120   3              }else
 121   2              {
 122   3                  sata.TX1_send_cnt = 0;
 123   3              }
 124   2          }
 125   1          
 126   1          /* 1, 检测到S2RI置1，即接收完毕                       */
 127   1          if( RI == 1 )
 128   1          {
 129   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 130   2              RI = 0;
 131   2              /* 3, 判断数据包是否接收完毕                           */
 132   2              if( !sata.RX1_rev_end_Flag )
 133   2              {
 134   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 135   3                  if( sata.RX1_rev_cnt > 128 )
 136   3                  {
 137   4                      sata.RX1_rev_cnt = 0;
 138   4                  }
 139   3      
 140   3                  /* 5, 依次将RX4_buf中数据接收（读S2BUF操作即为接收）*/
 141   3                  sata.RX1_buf[sata.RX1_rev_cnt] = SBUF;
 142   3                  sata.RX1_rev_cnt++;
 143   3              }
 144   2              /* 6, 重置接收完毕判断时间                              */
 145   2              sata.RX1_rev_timeout = 5;
 146   2          }
 147   1      }
 148          
 149          /**
 150           * @brief       是否接收完毕判断函数
 151           *
 152           * @param   
 153           *
 154           * @return  void
 155          **/
 156          void Tim0_ISR( void ) interrupt 1   //1ms
 157          {
 158   1          /* 1, 如果接收未超时                                             */
 159   1          if ( rs485.RX4_rev_timeout != 0 )  
 160   1          {
 161   2              rs485.RX4_rev_timeout--;
 162   2              /* 2, 如果接收超时                                          */
 163   2              if( rs485.RX4_rev_timeout == 0 )  
 164   2              {
 165   3                  if( rs485.RX4_rev_cnt > 0 )  
 166   3                  {   
 167   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 168   4                      rs485.RX4_rev_end_Flag = 1;    
 169   4                  }
 170   3              }
 171   2          } 
 172   1      
 173   1          /* 1, 如果接收未超时                                             */
 174   1          if ( sata.RX1_rev_timeout != 0 )  
 175   1          {
 176   2              sata.RX1_rev_timeout--;
 177   2              /* 2, 如果接收超时                                          */
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     06/27/2025 11:35:29 PAGE 4   

 178   2              if( sata.RX1_rev_timeout == 0 )  
 179   2              {
 180   3                  if( sata.RX1_rev_cnt > 0 )  
 181   3                  {   
 182   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 183   4                      sata.RX1_rev_end_Flag = 1;    
 184   4                  }
 185   3              }
 186   2          } 
 187   1      }
 188          
 189          
 190          // /**
 191          //  * @brief    串口1中断处理函数
 192          //  *
 193          //  * @param   
 194          //  *
 195          //  * @return  void
 196          // **/
 197          // void Uart1_ISR() interrupt 4
 198          // {
 199          //     if(TI == 1)
 200          //     {
 201          //         TI = 0;
 202          //         TX1_busy_Flag = 0;
 203          //     }
 204          //     if(RI == 1)
 205          //     {
 206          //         RI = 0;
 207          //     }
 208          // }
 209          
 210          // /**
 211          //  * @brief    串口重定向
 212          //  *
 213          //  * @param   c:字符串
 214          //  *
 215          //  * @return  c
 216          // **/
 217          // char putchar(char c)  // 串口重定向需要添加头文件stdio.h
 218          // {
 219          //     SBUF = c;
 220          //     while(TX1_busy_Flag);
 221          //     TX1_busy_Flag = 1;
 222          //     return c;
 223          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    413    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    528    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
