C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event_485( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt-1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt-2]<<8);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX4_buf[0] == ADDR_485 )
  34   3                  {
  35   4                      switch ( rs485.RX4_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3_485();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4_485();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6_485();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16_485();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          
  61          /**
  62           * @brief       modbus_rtu  无奇偶校验
  63           *
  64           * @param   void
  65           *
  66           * @return  void 
  67          **/
  68          void Modbus_Event_Sata( void )
  69          {
  70   1          uint16_t crc,rccrc;
  71   1          
  72   1          /*1.接收完毕                                           */
  73   1          if( sata.RX1_rev_end_Flag == 1 )
  74   1          {
  75   2              /*2.清空接收完毕标志位                              */    
  76   2              sata.RX1_rev_end_Flag = 0;
  77   2      
  78   2              /*3.CRC校验                                         */
  79   2              crc = MODBUS_CRC16(sata.RX1_buf, sata.RX1_rev_cnt-2);
  80   2              rccrc = (sata.RX1_buf[sata.RX1_rev_cnt-2]) | (sata.RX1_buf[sata.RX1_rev_cnt-1]<<8);
  81   2      
  82   2              /*4.清空接收计数                                    */
  83   2              sata.RX1_rev_cnt = 0; 
  84   2      
  85   2              /*5.CRC校验通过，进行地址域校验                      */
  86   2              if( crc == rccrc )
  87   2              {
  88   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  89   3                  if( sata.RX1_buf[0] == ADDR_SATA )
  90   3                  {
  91   4                      switch ( sata.RX1_buf[1] )
  92   4                      {
  93   5                          case 0x03:
  94   5                              Modbus_Fun3_Sata();
  95   5      
  96   5                              break;
  97   5      
  98   5                          case 0x04:
  99   5                              Modbus_Fun4_Sata();
 100   5                              
 101   5                              break;
 102   5      
 103   5                          case 0x06:
 104   5                              Modbus_Fun6_Sata();
 105   5      
 106   5                              break;  
 107   5      
 108   5                          case 0x10:
 109   5                              Modbus_Fun16_Sata();
 110   5      
 111   5                              break;  
 112   5                          default:
 113   5                              break;
 114   5                      }
 115   4                  }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 3   

 116   3              }
 117   2          }
 118   1      }
 119          
 120          /**
 121           * @brief       读输入寄存器  03
 122           *
 123           * @param   void
 124           *
 125           * @return  void 
 126          **/
 127          void Modbus_Fun3_485( void )
 128          {
 129   1          uint16_t i;
 130   1      
 131   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 132   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 133   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 134   1      
 135   1          rs485.TX4_buf[0]  = ADDR_485;                //Addr
 136   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
 137   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 138   1      
 139   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 140   1          {
 141   2              /*    每次循环前初始化byte_info                       */
 142   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 143   2              switch (i)
 144   2              {   
 145   3                  /*  40001 风速查询                     */
 146   3                  case 0x00:
 147   3      
 148   3      
 149   3                      break;
 150   3      
 151   3                  /*  40002 LED开关状态查询                     */    
 152   3                  case 0x01:
 153   3      
 154   3                      break;
 155   3      
 156   3                  /*  40003 3路220V开关使能查询                         */
 157   3                  case 0x02:    
 158   3      
 159   3                      break;
 160   3      
 161   3                  /*  40004 同步状态查询              */
 162   3                  case 0x03:    
 163   3      
 164   3      
 165   3                      break;
 166   3      
 167   3                  /*  40005 工作模式查询                     */
 168   3                  case 0x04:   
 169   3      
 170   3                      break;
 171   3      
 172   3                  /*  40006 报警温度查询                     */
 173   3                  case 5:   
 174   3              
 175   3      
 176   3                      break;
 177   3                  default:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 4   

 178   3                      break;
 179   3              }
 180   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 181   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 182   2          }
 183   1          slave_to_master_485(0x03,3 + modbus.byte_cnt);
 184   1      }
 185          
 186          
 187          /**
 188           * @brief       读输入寄存器  03
 189           *
 190           * @param   void
 191           *
 192           * @return  void 
 193          **/
 194          void Modbus_Fun3_Sata( void )
 195          {
 196   1          uint16_t i;
 197   1      
 198   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 199   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 200   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 201   1      
 202   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 203   1          sata.TX1_buf[1]  = 0x03;                   //Fun
 204   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 205   1      
 206   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 207   1          {
 208   2              /*    每次循环前初始化byte_info                       */
 209   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 210   2              switch (i)
 211   2              {   
 212   3                  /*  40001 平台加热开关                     */
 213   3                  case 0x00:
 214   3                      modbus.byte_info_H = 0x00;
 215   3                      modbus.byte_info_L = qdc_info.power_enable;
 216   3      
 217   3                      break;
 218   3      
 219   3                  /*  40002 LED开关状态查询                     */    
 220   3                  case 0x01:
 221   3                      modbus.byte_info_H = 0x00;
 222   3                      modbus.byte_info_L = qdc_info.led_switch;
 223   3      
 224   3                      break;
 225   3      
 226   3                  /*  40003 风扇                         */
 227   3                  case 0x02:    
 228   3                      modbus.byte_info_H = 0x00;
 229   3                      modbus.byte_info_L = qdc_info.fan_level;
 230   3      
 231   3                      break;
 232   3      
 233   3                  /*  40004 循环控制              */
 234   3                  case 0x03:    
 235   3                      modbus.byte_info_H = qdc_info.cir_level;
 236   3                      modbus.byte_info_L = qdc_info.cir_switch;
 237   3      
 238   3                      break;
 239   3      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 5   

 240   3                  /*  40005 循环控制                     */
 241   3                  case 0x04:   
 242   3                      modbus.byte_info_H = qdc_info.cir_stop_time;
 243   3                      modbus.byte_info_L = qdc_info.cir_start_time;
 244   3      
 245   3                      break;
 246   3      
 247   3                  /*  40004 搅拌控制              */
 248   3                  case 0x05:    
 249   3                      modbus.byte_info_H = qdc_info.stir_level;
 250   3                      modbus.byte_info_L = qdc_info.stir_switch;
 251   3      
 252   3                      break;
 253   3      
 254   3                  /*  40005 搅拌控制                     */
 255   3                  case 0x06:   
 256   3                      modbus.byte_info_H = qdc_info.stir_stop_time;
 257   3                      modbus.byte_info_L = qdc_info.stir_start_time;
 258   3      
 259   3                      break;
 260   3      
 261   3                  /*  40006 缺墨延时时间                     */
 262   3                  case 0x07:   
 263   3                      modbus.byte_info_H = 0x00;
 264   3                      modbus.byte_info_L = qdc_info.ink_out_time;
 265   3                      
 266   3                      break;
 267   3      
 268   3                  /*  40007 前、中加热报警温度                     */
 269   3                  case 0x08:   
 270   3                      modbus.byte_info_H = qdc_info.M_alarm_temp;
 271   3                      modbus.byte_info_L = qdc_info.F_alarm_temp;    
 272   3      
 273   3                      break;
 274   3      
 275   3                  /*  40008  后加热报警温度                      */
 276   3                  case 0x09:   
 277   3                      modbus.byte_info_H = 0x00;
 278   3                      modbus.byte_info_L = qdc_info.R_alarm_temp;    
 279   3                      
 280   3                      break;
 281   3      
 282   3                  default:
 283   3                      break;
 284   3              }
 285   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 286   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 287   2          }
 288   1          slave_to_master_Sata(0x03,3 + modbus.byte_cnt);
 289   1      }
 290          
 291          /**
 292           * @brief       读输出寄存器  04
 293           *
 294           * @param   void
 295           *
 296           * @return  void 
 297          **/
 298          void Modbus_Fun4_485( void )
 299          {
 300   1      
 301   1          /*  30001 30002  液位信息                   */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 6   

 302   1          qdc_info.level_info2 = rs485.RX4_buf[3];
 303   1          qdc_info.level_info1 = rs485.RX4_buf[4];
 304   1      
 305   1          qdc_info.level_info4 = rs485.RX4_buf[5];
 306   1          qdc_info.level_info3 = rs485.RX4_buf[6];
 307   1      
 308   1          qdc_info.ink1 =  qdc_info.level_info1 & 0x03;
 309   1          qdc_info.ink2 = (qdc_info.level_info1 & 0x0c) >> 2;
 310   1          qdc_info.ink3 = (qdc_info.level_info1 & 0x30) >> 4;
 311   1          qdc_info.ink4 = (qdc_info.level_info1 & 0xc0) >> 6;
 312   1          qdc_info.ink5 = (qdc_info.level_info2 & 0x03);
 313   1          qdc_info.ink6 = (qdc_info.level_info2 & 0x0c) >> 2;
 314   1          qdc_info.ink7 = (qdc_info.level_info2 & 0x30) >> 4;
 315   1          
 316   1          qdc_info.ink8  =  qdc_info.level_info3 & 0x03;
 317   1          qdc_info.ink9  = (qdc_info.level_info3 & 0x0c) >> 2;
 318   1          qdc_info.ink10 = (qdc_info.level_info3 & 0x30) >> 4;
 319   1          qdc_info.ink11 = (qdc_info.level_info3 & 0xc0) >> 6;
 320   1          qdc_info.ink12 = (qdc_info.level_info4 & 0x03);
 321   1          qdc_info.ink13 = (qdc_info.level_info4 & 0x0c) >> 2;
 322   1          qdc_info.ink14 = (qdc_info.level_info4 & 0x30) >> 4;
 323   1      
 324   1          if(( qdc_info.ink1 == 0x01 ) || ( qdc_info.ink2 == 0x01 ) || ( qdc_info.ink3 == 0x01 ) || ( qdc_info.i
             -nk4 == 0x01 ) \
 325   1          ||( qdc_info.ink5 == 0x01 ) || ( qdc_info.ink6 == 0x01 ) || ( qdc_info.ink7 == 0x01 ) || ( qdc_info.wa
             -ste_ink == 0x00)\
 326   1          ||( qdc_info.ink8 == 0x01 ) || ( qdc_info.ink9 == 0x01 ) || ( qdc_info.ink10 == 0x01 ) || ( qdc_info.i
             -nk11 == 0x01 ) \
 327   1          ||( qdc_info.ink12 == 0x01 ) || ( qdc_info.ink13 == 0x01 ) || ( qdc_info.ink14 == 0x01 ))
 328   1          {
 329   2              Buzzer = 0;
 330   2          }else
 331   1          {
 332   2              Buzzer = 1;
 333   2          }
 334   1      
 335   1          /*  30003 温湿度                   */
 336   1      
 337   1          qdc_info.dht11_hum = rs485.RX4_buf[7];
 338   1          qdc_info.dht11_temp = rs485.RX4_buf[8];
 339   1          qdc_info.EB_scan_cnt = 0;
 340   1          qdc_info.EB_statu_flag = 1;
 341   1      }
 342          
 343          
 344          /**
 345           * @brief       读输出寄存器  04
 346           *
 347           * @param   void
 348           *
 349           * @return  void 
 350          **/
 351          void Modbus_Fun4_Sata( void )
 352          {
 353   1          uint16_t i;
 354   1      
 355   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 356   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 357   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 358   1      
 359   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 360   1          sata.TX1_buf[1]  = 0x04;                   //Fun
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 7   

 361   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 362   1      
 363   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 364   1          {
 365   2              /*    每次循环前初始化byte_info                       */
 366   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 367   2              switch (i)
 368   2              {
 369   3                  /*  30001  1~7通道液位信息                           */
 370   3                  case 0x00:
 371   3                      modbus.byte_info_H = qdc_info.level_info2;
 372   3                      modbus.byte_info_L = qdc_info.level_info1;
 373   3      
 374   3                      break;
 375   3      
 376   3                  /*  30002 废墨液位信息                 */
 377   3                  case 0x01:
 378   3                      modbus.byte_info_H = qdc_info.level_info4;
 379   3                      modbus.byte_info_L = qdc_info.level_info3;
 380   3      
 381   3                      break;
 382   3      
 383   3                  /*  30003 废墨液位信息                 */
 384   3                  case 0x02:
 385   3                      waste_ink_scan();
 386   3                      modbus.byte_info_H = qdc_info.EB_statu_flag;
 387   3                      modbus.byte_info_L = qdc_info.waste_ink;
 388   3      
 389   3                      break;
 390   3      
 391   3                  /*  30004 环境温湿度查询                   */
 392   3                  case 0x03:
 393   3                      modbus.byte_info_H = qdc_info.dht11_hum;
 394   3                      modbus.byte_info_L = qdc_info.dht11_temp;
 395   3      
 396   3                      break;
 397   3      
 398   3                  /*  30005 NTC1、2温度                  */
 399   3                  case 0x04:
 400   3                      modbus.byte_info_H = temp.temp_value2;
 401   3                      modbus.byte_info_L = temp.temp_value1;
 402   3      
 403   3                      break;
 404   3                      
 405   3                  /*  30006 NTC3温度                  */
 406   3                  case 0x05:
 407   3                      modbus.byte_info_H = 0x00;
 408   3                      modbus.byte_info_L = temp.temp_value3;
 409   3      
 410   3                      break;
 411   3      
 412   3                  default:
 413   3                      break;
 414   3              }
 415   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 416   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 417   2          }
 418   1          slave_to_master_Sata(0x04,3 + modbus.byte_cnt);
 419   1      }
 420          
 421          /**
 422           * @brief       写单个输出寄存器  06
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 8   

 423           *
 424           * @param   void
 425           *
 426           * @return  void 
 427          **/
 428          void Modbus_Fun6_485( void )
 429          {
 430   1          switch (rs485.RX4_buf[3])
 431   1          {
 432   2              /*  40001  风速设置                 */
 433   2              case 0x00:                  
 434   2      
 435   2                  break;
 436   2      
 437   2              /*  40002  LED 开关状态设置                          */
 438   2              case 0x01:                                         
 439   2      
 440   2      
 441   2                  break;
 442   2      
 443   2              /*  40003 三路220V输出使能设置                          */
 444   2              case 0x02:                                         
 445   2      
 446   2                  break;  
 447   2                  
 448   2              /*  40004  循环控制                   */
 449   2              case 0x03:                                          
 450   2                  qdc_info.cir_switch = sata.RX1_buf[5];
 451   2      
 452   2                  eeprom_data_record();
 453   2      
 454   2                  break;
 455   2      
 456   2              /*  40005  搅拌控制                   */
 457   2              case 0x05:                                         
 458   2                  qdc_info.stir_switch = sata.RX1_buf[5];
 459   2      
 460   2                  eeprom_data_record();
 461   2      
 462   2                  break;
 463   2      
 464   2              /*  40006  缺墨延时时间                   */
 465   2              case 0x07:                                         
 466   2                  qdc_info.ink_out_time = sata.RX1_buf[5];  
 467   2                  eeprom_data_record();
 468   2      
 469   2                  break;
 470   2      
 471   2              default:
 472   2                  break;   
 473   2          }
 474   1          
 475   1          slave_to_master_Sata(0x06,8);
 476   1          
 477   1      }
 478          
 479          
 480          /**
 481           * @brief       写单个输出寄存器  06
 482           *
 483           * @param   void
 484           *
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 9   

 485           * @return  void 
 486          **/
 487          void Modbus_Fun6_Sata( void )
 488          {
 489   1          switch (sata.RX1_buf[3])
 490   1          {
 491   2              /*  40001  平台加热控制                 */
 492   2              case 0x00:                  
 493   2                  qdc_info.power_enable = sata.RX1_buf[5];
 494   2      
 495   2                  slave_to_master_Sata(0x06,8);
 496   2                  eeprom_data_record();
 497   2      
 498   2                  break;
 499   2      
 500   2              /*  40002  LED 开关状态设置                          */
 501   2              case 0x01:        
 502   2                  qdc_info.led_switch = sata.RX1_buf[5];                                 
 503   2                  led_ctrl(sata.RX1_buf[5]);
 504   2      
 505   2                  slave_to_master_Sata(0x06,8);
 506   2                  eeprom_data_record();    
 507   2      
 508   2                  break;
 509   2      
 510   2              /*  40003 风扇控制                         */
 511   2              case 0x02: 
 512   2                  qdc_info.fan_level = sata.RX1_buf[5];                                     
 513   2                  fan_ctrl(qdc_info.fan_level);
 514   2      
 515   2                  slave_to_master_Sata(0x06,8);
 516   2                  eeprom_data_record();
 517   2      
 518   2                  break;  
 519   2                  
 520   2              /*  40004  循环控制                   */
 521   2              case 0x03:            
 522   2                  send_to_EB_06(0x03,0x00,sata.RX1_buf[5]);       
 523   2      
 524   2                  break;
 525   2      
 526   2              /*  40005  循环控制                   */
 527   2              case 0x04:                   
 528   2                  //send_to_EB_06(0x04,sata.RX1_buf[4],sata.RX1_buf[5]);                      
 529   2      
 530   2                  break;
 531   2                  
 532   2              /*  40004  搅拌控制                   */
 533   2              case 0x05:            
 534   2                  send_to_EB_06(0x05,0x00,sata.RX1_buf[5]);       
 535   2      
 536   2                  break;
 537   2      
 538   2              /*  40005  搅拌控制                   */
 539   2              case 0x06:                   
 540   2                  //send_to_EB_06(0x04,sata.RX1_buf[4],sata.RX1_buf[5]);                      
 541   2      
 542   2                  break;
 543   2      
 544   2              /*  40006  缺墨延时时间                   */
 545   2              case 0x07:                
 546   2                 send_to_EB_06(0x07,0x00,sata.RX1_buf[5]);                       
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 10  

 547   2      
 548   2                  break;
 549   2              /*  40007  报警温度                   */
 550   2              case 0x08:       
 551   2                  qdc_info.M_alarm_temp = sata.RX1_buf[4]; 
 552   2                  qdc_info.F_alarm_temp = sata.RX1_buf[5];                                           
 553   2                  slave_to_master_Sata(0x06,8);
 554   2                  eeprom_data_record();
 555   2      
 556   2                  break;
 557   2      
 558   2              /*  40008  报警温度                   */
 559   2              case 0x09:                             
 560   2                  qdc_info.R_alarm_temp = sata.RX1_buf[5];                                           
 561   2                  slave_to_master_Sata(0x06,8);
 562   2                  eeprom_data_record();            
 563   2      
 564   2                  break;
 565   2      
 566   2              default:
 567   2                  break;   
 568   2          }
 569   1      }
 570          
 571          /**
 572           * @brief       写单个输出寄存器  06
 573           *
 574           * @param   void
 575           *
 576           * @return  void 
 577          **/
 578          void Modbus_Fun16_Sata( void )
 579          {
 580   1          uint16_t crc;
 581   1          uint8_t send_buf[17];
 582   1          if( sata.RX1_buf[3] == 0x06 )
 583   1          {
 584   2              qdc_info.F_alarm_temp = sata.RX1_buf[8];
 585   2              qdc_info.M_alarm_temp = sata.RX1_buf[7]; 
 586   2              qdc_info.R_alarm_temp = sata.RX1_buf[10]; 
 587   2              slave_to_master_Sata(0x10,8);
 588   2              eeprom_data_record(); 
 589   2          }else
 590   1          {
 591   2              qdc_info.cir_level_m = sata.RX1_buf[7];
 592   2              qdc_info.cir_switch_m = sata.RX1_buf[8];
 593   2              qdc_info.cir_stop_time_m  = sata.RX1_buf[9];
 594   2              qdc_info.cir_start_time_m = sata.RX1_buf[10];
 595   2      
 596   2              qdc_info.stir_level_m = sata.RX1_buf[11];
 597   2              qdc_info.stir_switch_m = sata.RX1_buf[12];
 598   2              qdc_info.stir_stop_time_m = sata.RX1_buf[13];
 599   2              qdc_info.stir_start_time_m = sata.RX1_buf[14];
 600   2      
 601   2              memcpy(send_buf,sata.RX1_buf,15);
 602   2      
 603   2              send_buf[0] = ADDR_485;
 604   2      
 605   2              crc = MODBUS_CRC16(send_buf,15);
 606   2      
 607   2              send_buf[15] = crc>>8;
 608   2              send_buf[16] = crc;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 11  

 609   2      
 610   2              memcpy(rs485.TX4_buf,send_buf,17);
 611   2                  
 612   2              rs485.TX4_send_bytelength = 17;
 613   2              DR_485 = 1;                                 //485可以发送
 614   2              delay_ms(2);
 615   2              S4CON |= S4TI;                              //开始发送
 616   2              delay_ms(1);
 617   2          }
 618   1      }
 619          /**
 620           * @brief       写多个输出寄存器  16
 621           *
 622           * @param   void
 623           *
 624           * @return  void 
 625          **/
 626          void Modbus_Fun16_485( void )
 627          {
 628   1          if( rs485.conntct_statu == 1 )
 629   1          {
 630   2              qdc_info.cir_level = qdc_info.cir_level_m;
 631   2              qdc_info.cir_start_time = qdc_info.cir_start_time_m;
 632   2              qdc_info.cir_stop_time = qdc_info.cir_stop_time_m;
 633   2              qdc_info.cir_switch = qdc_info.cir_switch_m;
 634   2      
 635   2              qdc_info.stir_level = qdc_info.stir_level_m;
 636   2              qdc_info.stir_start_time = qdc_info.stir_start_time_m;
 637   2              qdc_info.stir_stop_time = qdc_info.stir_stop_time_m;
 638   2              qdc_info.stir_switch = qdc_info.stir_switch_m;
 639   2              eeprom_data_record();
 640   2          }
 641   1          rs485.connect_flag = 1;
 642   1          delay_ms(50);
 643   1          rs485.conntct_statu = 1;
 644   1          slave_to_master_Sata(0x10,8);
 645   1      }
 646          
 647          
 648          /**
 649           * @brief       从机回复主机
 650           *  
 651           * @param   code_num:功能码       
 652           * @param   length:数据长度        
 653           * 
 654            @return  crc16:crc校验的值 2byte
 655           */
 656          void slave_to_master_485(uint8_t code_num,uint8_t length)
 657          {
 658   1          uint16_t crc;
 659   1      
 660   1          switch (code_num)
 661   1          {
 662   2              case 0x03:
 663   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 664   2      
 665   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 666   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 667   2      
 668   2                  rs485.TX4_send_bytelength = length + 2;
 669   2                  
 670   2                  break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 12  

 671   2              case 0x04:
 672   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 673   2      
 674   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 675   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 676   2      
 677   2                  rs485.TX4_send_bytelength = length + 2;
 678   2                  
 679   2                  break;    
 680   2      
 681   2              case 0x06:
 682   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 683   2      
 684   2                  rs485.TX4_send_bytelength = length;
 685   2                  
 686   2                  break;   
 687   2      
 688   2              case 0x10:
 689   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 690   2              
 691   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 692   2      
 693   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 694   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 695   2              
 696   2                  rs485.TX4_send_bytelength = length;
 697   2                  
 698   2                  break;         
 699   2      
 700   2              default:
 701   2                  break;
 702   2          }
 703   1      
 704   1          DR_485 = 1;                                 //485可以发送
 705   1          delay_ms(2);
 706   1          S4CON |= S4TI;                              //开始发送
 707   1          delay_ms(1);
 708   1      }
 709          
 710          
 711          /**
 712           * @brief       从机回复主机
 713           *  
 714           * @param   code_num:功能码       
 715           * @param   length:数据长度        
 716           * 
 717            @return  crc16:crc校验的值 2byte
 718           */
 719          void slave_to_master_Sata(uint8_t code_num,uint8_t length)
 720          {
 721   1          uint16_t crc;
 722   1      
 723   1          switch (code_num)
 724   1          {
 725   2              case 0x03:
 726   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 727   2      
 728   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 729   2                  sata.TX1_buf[length] = crc;            //CRC L
 730   2      
 731   2                  sata.TX1_send_bytelength = length + 2;
 732   2                  
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 13  

 733   2                  break;
 734   2              case 0x04:
 735   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 736   2      
 737   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 738   2                  sata.TX1_buf[length] = crc;            //CRC L
 739   2      
 740   2                  sata.TX1_send_bytelength = length + 2;
 741   2                  
 742   2                  break;    
 743   2      
 744   2              case 0x06:
 745   2                  memcpy(sata.TX1_buf,sata.RX1_buf,8);
 746   2      
 747   2                  sata.TX1_send_bytelength = length;
 748   2                  
 749   2                  break;   
 750   2      
 751   2              case 0x10:
 752   2                  memcpy(sata.TX1_buf,sata.RX1_buf,6);
 753   2              
 754   2                  crc = MODBUS_CRC16(sata.TX1_buf,6);
 755   2      
 756   2                  sata.TX1_buf[6] = crc;                 //CRC H
 757   2                  sata.TX1_buf[7] = crc>>8;              //CRC L
 758   2      
 759   2                  sata.TX1_send_bytelength = length;
 760   2      
 761   2                  break;         
 762   2      
 763   2              default:
 764   2                  break;
 765   2          }
 766   1          TI  = 1;                              //开始发送
 767   1          delay_ms(1);
 768   1      }
 769          
 770          /**
 771           * @brief       crc校验函数
 772           * 
 773           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 774           * @param   length:数据长度           
 775           * 
 776            @return  crc16:crc校验的值 2byte
 777           */
 778          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 779          {
 780   1              uint8_t i;
 781   1              uint16_t        crc16;
 782   1      
 783   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 784   1              crc16 = 0xffff; 
 785   1      
 786   1              do
 787   1              {
 788   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 789   2                      crc16 ^= (uint16_t)*buf;                //
 790   2                      for(i=0; i<8; i++)              
 791   2                      {
 792   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 14  

 793   3                              if(crc16 & 1)
 794   3                  {
 795   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 796   4                  }
 797   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 798   3                  else
 799   3                  {
 800   4                      crc16 >>= 1;
 801   4                  }           
 802   3                      }
 803   2                      buf++;
 804   2              }while(--length != 0);
 805   1      
 806   1              return  (crc16);
 807   1      }
 808          
 809          void waste_ink_scan( void )
 810          {
 811   1              if( WASTE_INK == 0 )
 812   1              {
 813   2                  qdc_info.waste_ink = 0;
 814   2              }else
 815   1              {
 816   2                  qdc_info.waste_ink = 1;
 817   2              }
 818   1      }
 819          
 820          void send_to_EB_16( void )
 821          {
 822   1          uint8_t send_buf[19];
 823   1          uint16_t crc;
 824   1      
 825   1          send_buf[0] = 0xE1;
 826   1          send_buf[1] = 0x10;
 827   1          send_buf[2] = 0x00;
 828   1          send_buf[3] = 0x00;
 829   1          send_buf[4] = 0x00;
 830   1          send_buf[5] = 0x05;
 831   1          send_buf[6] = 0x0a;
 832   1      
 833   1          send_buf[7] = qdc_info.cir_level;
 834   1          send_buf[8] = qdc_info.cir_switch;
 835   1      
 836   1          send_buf[9] = qdc_info.cir_stop_time;
 837   1          send_buf[10] = qdc_info.cir_start_time;
 838   1      
 839   1          send_buf[11] = qdc_info.stir_level;
 840   1          send_buf[12] = qdc_info.stir_switch;
 841   1      
 842   1          send_buf[13] = qdc_info.stir_stop_time;
 843   1          send_buf[14] = qdc_info.stir_start_time;
 844   1      
 845   1          send_buf[15] = 0x00;
 846   1          send_buf[16] = qdc_info.ink_out_time;
 847   1      
 848   1          crc = MODBUS_CRC16(send_buf,17);
 849   1      
 850   1          send_buf[17] = crc>>8;
 851   1          send_buf[18] = crc;
 852   1      
 853   1          memcpy(rs485.TX4_buf,send_buf,19);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 15  

 854   1          
 855   1          rs485.TX4_send_bytelength = 19;
 856   1          DR_485 = 1;                                 //485可以发送
 857   1          delay_ms(2);
 858   1          S4CON |= S4TI;                              //开始发送
 859   1          delay_ms(1);
 860   1      }
 861          
 862          
 863          void send_to_EB_06( uint8_t addr, uint8_t val_H, uint8_t val_L)
 864          {
 865   1          uint8_t send_buf[8];
 866   1          uint16_t crc;
 867   1      
 868   1          send_buf[0] = ADDR_485;
 869   1          send_buf[1] = 0x06;
 870   1          send_buf[2] = 0x00;
 871   1          send_buf[3] = addr;
 872   1          send_buf[4] = val_H;
 873   1          send_buf[5] = val_L;
 874   1      
 875   1          crc = MODBUS_CRC16(send_buf,6);
 876   1      
 877   1          send_buf[6] = crc>>8;
 878   1          send_buf[7] = crc;
 879   1      
 880   1          memcpy(rs485.TX4_buf,send_buf,8);
 881   1      
 882   1          rs485.TX4_send_bytelength = 8;
 883   1          DR_485 = 1;                                 //485可以发送
 884   1          delay_ms(2);
 885   1          S4CON |= S4TI;                              //开始发送
 886   1          delay_ms(1);
 887   1      }
 888          
 889          void send_to_EB_04( void )
 890          {
 891   1          uint8_t send_buf[8];
 892   1      
 893   1          send_buf[0] = 0xE1;
 894   1          send_buf[1] = 0x04;
 895   1          send_buf[2] = 0x00;
 896   1          send_buf[3] = 0x00;
 897   1          send_buf[4] = 0x00;
 898   1          send_buf[5] = 0x03;
 899   1          send_buf[6] = 0x6B;
 900   1          send_buf[7] = 0xA6;
 901   1      
 902   1          memcpy(rs485.TX4_buf,send_buf,8);
 903   1      
 904   1          rs485.TX4_send_bytelength = 8;
 905   1          DR_485 = 1;                                 //485可以发送
 906   1          delay_ms(2);
 907   1          S4CON |= S4TI;                              //开始发送
 908   1          delay_ms(1);
 909   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2655    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      63
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/27/2025 11:35:30 PAGE 16  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
